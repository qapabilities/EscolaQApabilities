# üöÄ CD Pipeline - Continuous Deployment to AKS
# Escola QApabilities - Student Service
# 
# Triggers: Push para main + Manual
# Jobs: Build & Push Docker ‚Üí ACR, Deploy ‚Üí AKS, Health Checks

name: CD - Deploy para AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  AZURE_RESOURCE_GROUP: 'rg-escola-qapabilities'
  AZURE_CLUSTER_NAME: 'aks-escola-qapabilities'
  AZURE_REGISTRY_NAME: 'crescolaqapabilities'
  IMAGE_NAME: 'student-service'
  NAMESPACE: 'escola-qapabilities'
  DEPLOYMENT_NAME: 'student-service'

jobs:
  # ============================================================================
  # JOB 1: BUILD & PUSH DOCKER IMAGE
  # ============================================================================
  build-and-push:
    name: üê≥ Build & Push to ACR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    # Checkout do c√≥digo
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: üîë Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Login no Azure Container Registry
    - name: üê≥ Login to ACR
      run: |
        az acr login --name ${{ env.AZURE_REGISTRY_NAME }}
        
    # Configurar metadados da imagem
    - name: üè∑Ô∏è Extract Metadata
      id: meta
      run: |
        IMAGE_TAG="${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}"
        
        if [ "${{ github.event_name }}" = "push" ]; then
          VERSION="v$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}"
        else
          VERSION="manual-$(date +%Y%m%d%H%M%S)"
        fi
        
        FULL_TAG="${IMAGE_TAG}:${VERSION}"
        LATEST_TAG="${IMAGE_TAG}:latest"
        
        echo "tags=${FULL_TAG}" >> $GITHUB_OUTPUT
        echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        
        echo "üè∑Ô∏è Image Tag: ${FULL_TAG}"
        echo "üè∑Ô∏è Latest Tag: ${LATEST_TAG}"
        
    # Build e Push da imagem Docker
    - name: üèóÔ∏è Build & Push Docker Image
      run: |
        # Build da imagem
        docker build \
          --tag ${{ steps.meta.outputs.tags }} \
          --tag ${{ steps.meta.outputs.latest }} \
          --build-arg BUILD_VERSION=${{ steps.meta.outputs.version }} \
          .
          
        # Push para ACR
        docker push ${{ steps.meta.outputs.tags }}
        docker push ${{ steps.meta.outputs.latest }}
        
        echo "‚úÖ Imagem enviada para ACR: ${{ steps.meta.outputs.tags }}"

  # ============================================================================
  # JOB 2: DEPLOY TO AKS
  # ============================================================================
  deploy-to-aks:
    name: ‚ò∏Ô∏è Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.get-url.outputs.app-url }}
      
    steps:
    # Checkout do c√≥digo
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: üîë Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: ‚öôÔ∏è Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Verificar conectividade com cluster
    - name: üîç Check Cluster Connection
      run: |
        kubectl cluster-info
        kubectl get nodes
        
    # Aplicar configura√ß√µes base (se necess√°rio)
    - name: üìã Apply Base Configurations
      run: |
        # Aplicar configura√ß√µes base
        echo "üìã Applying base configurations..."
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        
        echo "‚úÖ Base configurations applied!"
        echo "üìã Using SQLite database - no external database required!"
        
    # Atualizar imagem no deployment
    - name: üîÑ Update Deployment Image
      run: |
        # Atualizar a imagem no manifesto
        sed -i "s|escolaqapabilities/student-service:latest|${{ needs.build-and-push.outputs.image-tag }}|g" k8s/student-service.yaml
        
        # Aplicar o deployment atualizado
        kubectl apply -f k8s/student-service.yaml
        kubectl apply -f k8s/ingress.yaml
        
    # Aguardar deployment estar pronto
    - name: ‚è≥ Wait for Deployment
      run: |
        echo "‚è≥ Aguardando deployment estar pronto..."
        kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --timeout=600s
          
        echo "‚úÖ Deployment conclu√≠do com sucesso!"
        
    # Obter URL da aplica√ß√£o
    - name: üåê Get Application URL
      id: get-url
      run: |
        # Aguardar IP externo do Load Balancer
        echo "üîç Obtendo IP externo do Load Balancer..."
        
        for i in {1..30}; do
          EXTERNAL_IP=$(kubectl get service ingress-nginx-controller \
            -n ingress-nginx \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
          if [ ! -z "$EXTERNAL_IP" ]; then
            echo "üåê IP Externo: $EXTERNAL_IP"
            echo "app-url=http://$EXTERNAL_IP" >> $GITHUB_OUTPUT
            break
          fi
          
          echo "‚è≥ Aguardando IP externo... (tentativa $i/30)"
          sleep 10
        done
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "‚ö†Ô∏è IP externo n√£o encontrado, usando NodePort"
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          NODE_PORT=$(kubectl get service student-service-nodeport -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
          echo "app-url=http://$NODE_IP:$NODE_PORT" >> $GITHUB_OUTPUT
        fi

  # ============================================================================
  # JOB 3: HEALTH CHECKS & API TESTS
  # ============================================================================
  health-checks:
    name: üè• Health Checks & API Tests
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks]
    
    steps:
    # Checkout para testes de API
    - name: üì• Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: üîë Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: ‚öôÔ∏è Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Health Check b√°sico
    - name: üè• Basic Health Check
      run: |
        echo "üè• Verificando sa√∫de dos pods..."
        
        # Verificar se pods est√£o rodando
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Verificar logs dos pods
        echo "üìã √öltimos logs do deployment:"
        kubectl logs deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --tail=20
          
    # Test do endpoint de health
    - name: üîç Health Endpoint Test
      run: |
        # Obter IP do servi√ßo
        CLUSTER_IP=$(kubectl get service student-service-clusterip \
          -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.spec.clusterIP}')
          
        echo "üîç Testando health endpoint: http://$CLUSTER_IP:8080/health"
        
        # Port forward tempor√°rio para teste
        kubectl port-forward service/student-service-clusterip 8080:8080 -n ${{ env.NAMESPACE }} &
        PORT_FORWARD_PID=$!
        
        # Aguardar port forward estar pronto
        sleep 10
        
        # Testar endpoint
        for i in {1..5}; do
          if curl -f http://localhost:8080/health; then
            echo "‚úÖ Health check passou!"
            break
          else
            echo "‚è≥ Tentativa $i/5 falhou, tentando novamente..."
            sleep 10
          fi
        done
        
        # Matar port forward
        kill $PORT_FORWARD_PID
        
    # Test b√°sico de autentica√ß√£o
    - name: üîë Authentication Test
      run: |
        echo "üîë Testando endpoint de autentica√ß√£o..."
        
        # Port forward para testes
        kubectl port-forward service/student-service-clusterip 8080:8080 -n ${{ env.NAMESPACE }} &
        PORT_FORWARD_PID=$!
        sleep 10
        
        # Testar login
        if curl -X POST http://localhost:8080/api/auth/login \
          -H "Content-Type: application/json" \
          -d '{"email": "admin@qapabilities.com", "password": "admin123"}'; then
          echo "‚úÖ Autentica√ß√£o funcionando!"
        else
          echo "‚ùå Falha na autentica√ß√£o"
        fi
        
        kill $PORT_FORWARD_PID

  # ============================================================================
  # JOB 4: DEPLOYMENT SUCCESS
  # ============================================================================
  deployment-success:
    name: ‚úÖ Deployment Success
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks, health-checks]
    if: success()
    
    steps:
    - name: üéâ Deployment Success Notification
      run: |
        echo "üéâ DEPLOYMENT REALIZADO COM SUCESSO!"
        echo ""
        echo "üì¶ Imagem: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "üåê URL: ${{ needs.deploy-to-aks.outputs.app-url }}"
        echo "üè• Health Checks: ‚úÖ Passou"
        echo "üîë Auth Tests: ‚úÖ Passou"
        echo ""
        echo "üöÄ Aplica√ß√£o est√° rodando no AKS!"

  # ============================================================================
  # JOB 5: ROLLBACK (se falhar)
  # ============================================================================
  rollback-on-failure:
    name: üîÑ Auto Rollback
    runs-on: ubuntu-latest
    needs: [deploy-to-aks, health-checks]
    if: failure()
    
    steps:
    # Login no Azure
    - name: üîë Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl  
    - name: ‚öôÔ∏è Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Realizar rollback
    - name: üîÑ Perform Rollback
      run: |
        echo "‚ùå Deployment falhou! Verificando se h√° vers√£o anterior para rollback..."
        
        # Verificar se deployment existe
        if kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} &> /dev/null; then
          echo "üìã Deployment encontrado, fazendo rollback..."
          
          # Rollback para vers√£o anterior
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }}
            
          # Aguardar rollback completar
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s
            
          echo "üîÑ Rollback conclu√≠do!"
        else
          echo "‚ö†Ô∏è Deployment n√£o existe ainda, limpando recursos criados..."
          
          # Limpar recursos criados no deploy que falhou
          kubectl delete all -l app.kubernetes.io/name=student-service -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          echo "üßπ Recursos limpos!"
        fi
        
    - name: üì¢ Rollback Notification
      run: |
        echo "üîÑ ROLLBACK REALIZADO!"
        echo "‚ùå O deployment falhou e foi revertido para a vers√£o anterior"
        echo "üìã Verifique os logs para identificar o problema"