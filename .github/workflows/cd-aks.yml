# ğŸš€ CD Pipeline - Continuous Deployment to AKS
# Escola QApabilities - Student Service
# 
# Triggers: Push para main + Manual
# Jobs: Build & Push Docker â†’ ACR, Deploy â†’ AKS, Health Checks

name: CD - Deploy para AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  AZURE_RESOURCE_GROUP: 'rg-escola-qapabilities'
  AZURE_CLUSTER_NAME: 'aks-escola-qapabilities'
  AZURE_REGISTRY_NAME: 'crescolaqapabilities'
  IMAGE_NAME: 'student-service'
  NAMESPACE: 'escola-qapabilities'
  DEPLOYMENT_NAME: 'student-service'

jobs:
  # ============================================================================
  # JOB 1: BUILD & PUSH DOCKER IMAGE
  # ============================================================================
  build-and-push:
    name: ğŸ³ Build & Push to ACR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    # Checkout do cÃ³digo
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Login no Azure Container Registry
    - name: ğŸ³ Login to ACR
      run: |
        az acr login --name ${{ env.AZURE_REGISTRY_NAME }}
        
    # Configurar metadados da imagem
    - name: ğŸ·ï¸ Extract Metadata
      id: meta
      run: |
        IMAGE_TAG="${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}"
        
        if [ "${{ github.event_name }}" = "push" ]; then
          VERSION="v$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}"
        else
          VERSION="manual-$(date +%Y%m%d%H%M%S)"
        fi
        
        FULL_TAG="${IMAGE_TAG}:${VERSION}"
        LATEST_TAG="${IMAGE_TAG}:latest"
        
        echo "tags=${FULL_TAG}" >> $GITHUB_OUTPUT
        echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        
        echo "ğŸ·ï¸ Image Tag: ${FULL_TAG}"
        echo "ğŸ·ï¸ Latest Tag: ${LATEST_TAG}"
        
    # Build e Push da imagem Docker
    - name: ğŸ—ï¸ Build & Push Docker Image
      run: |
        # Build da imagem
        docker build \
          --tag ${{ steps.meta.outputs.tags }} \
          --tag ${{ steps.meta.outputs.latest }} \
          --build-arg BUILD_VERSION=${{ steps.meta.outputs.version }} \
          .
          
        # Push para ACR
        docker push ${{ steps.meta.outputs.tags }}
        docker push ${{ steps.meta.outputs.latest }}
        
        echo "âœ… Imagem enviada para ACR: ${{ steps.meta.outputs.tags }}"

  # ============================================================================
  # JOB 2: DEPLOY TO AKS
  # ============================================================================
  deploy-to-aks:
    name: â˜¸ï¸ Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.get-url.outputs.app-url }}
      
    steps:
    # Checkout do cÃ³digo
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Verificar conectividade com cluster
    - name: ğŸ” Check Cluster Connection
      run: |
        kubectl cluster-info
        kubectl get nodes
        
    # Aplicar configuraÃ§Ãµes base (se necessÃ¡rio)
    - name: ğŸ“‹ Apply Base Configurations
      run: |
        # Aplicar configuraÃ§Ãµes base
        echo "ğŸ“‹ Applying base configurations..."
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        
        echo "âœ… Base configurations applied!"
        echo "ğŸ“‹ Using SQLite database - no external database required!"
        
    # Atualizar imagem no deployment
    - name: ğŸ”„ Update Deployment Image
      run: |
        # Atualizar a imagem no manifesto
        sed -i "s|escolaqapabilities/student-service:latest|${{ needs.build-and-push.outputs.image-tag }}|g" k8s/student-service.yaml
        
        # Aplicar o deployment atualizado
        kubectl apply -f k8s/student-service.yaml
        kubectl apply -f k8s/ingress.yaml
        
    # Aguardar deployment estar pronto
    - name: â³ Wait for Deployment
      run: |
        echo "â³ Aguardando deployment estar pronto..."
        kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --timeout=600s
          
        echo "âœ… Deployment concluÃ­do com sucesso!"
        
    # Obter URL da aplicaÃ§Ã£o
    - name: ğŸŒ Get Application URL
      id: get-url
      run: |
        # Aguardar IP externo do Load Balancer
        echo "ğŸ” Obtendo IP externo do Load Balancer..."
        
        for i in {1..30}; do
          EXTERNAL_IP=$(kubectl get service ingress-nginx-controller \
            -n ingress-nginx \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
          if [ ! -z "$EXTERNAL_IP" ]; then
            echo "ğŸŒ IP Externo: $EXTERNAL_IP"
            echo "app-url=http://$EXTERNAL_IP" >> $GITHUB_OUTPUT
            break
          fi
          
          echo "â³ Aguardando IP externo... (tentativa $i/30)"
          sleep 10
        done
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "âš ï¸ IP externo nÃ£o encontrado, usando NodePort"
          NODE_IP=$(kubectl get nodes -o jsonpath='{.items[0].status.addresses[?(@.type=="ExternalIP")].address}')
          NODE_PORT=$(kubectl get service student-service-nodeport -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.ports[0].nodePort}')
          echo "app-url=http://$NODE_IP:$NODE_PORT" >> $GITHUB_OUTPUT
        fi

  # ============================================================================
  # JOB 3: HEALTH CHECKS & API TESTS
  # ============================================================================
  health-checks:
    name: ğŸ¥ Health Checks & API Tests
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks]
    
    steps:
    # Checkout para testes de API
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Health Check bÃ¡sico
    - name: ğŸ¥ Basic Health Check
      run: |
        echo "ğŸ¥ Verificando saÃºde dos pods..."
        
        # Verificar se pods estÃ£o rodando
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Verificar logs dos pods
        echo "ğŸ“‹ Ãšltimos logs do deployment:"
        kubectl logs deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --tail=20
          
    # Test do endpoint de health
    - name: ğŸ” Health Endpoint Test
      run: |
        # Obter IP do serviÃ§o
        CLUSTER_IP=$(kubectl get service student-service-clusterip \
          -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.spec.clusterIP}')
          
        echo "ğŸ” Testando health endpoint: http://$CLUSTER_IP:8080/health"
        
        # Port forward temporÃ¡rio para teste
        kubectl port-forward service/student-service-clusterip 8080:8080 -n ${{ env.NAMESPACE }} &
        PORT_FORWARD_PID=$!
        
        # Aguardar port forward estar pronto
        sleep 10
        
        # Testar endpoint
        for i in {1..5}; do
          if curl -f http://localhost:8080/health; then
            echo "âœ… Health check passou!"
            break
          else
            echo "â³ Tentativa $i/5 falhou, tentando novamente..."
            sleep 10
          fi
        done
        
        # Matar port forward
        kill $PORT_FORWARD_PID
        
    # Test bÃ¡sico de autenticaÃ§Ã£o
    - name: ğŸ”‘ Authentication Test
      run: |
        echo "ğŸ”‘ Testando endpoint de autenticaÃ§Ã£o..."
        
        # Port forward para testes
        kubectl port-forward service/student-service-clusterip 8080:8080 -n ${{ env.NAMESPACE }} &
        PORT_FORWARD_PID=$!
        sleep 10
        
        # Testar login
        if curl -X POST http://localhost:8080/api/auth/login \
          -H "Content-Type: application/json" \
          -d '{"email": "admin@qapabilities.com", "password": "admin123"}'; then
          echo "âœ… AutenticaÃ§Ã£o funcionando!"
        else
          echo "âŒ Falha na autenticaÃ§Ã£o"
        fi
        
        kill $PORT_FORWARD_PID

  # ============================================================================
  # JOB 4: DEPLOYMENT SUCCESS
  # ============================================================================
  deployment-success:
    name: âœ… Deployment Success
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks, health-checks]
    if: success()
    
    steps:
    - name: ğŸ‰ Deployment Success Notification
      run: |
        echo "ğŸ‰ DEPLOYMENT REALIZADO COM SUCESSO!"
        echo ""
        echo "ğŸ“¦ Imagem: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "ğŸŒ URL: ${{ needs.deploy-to-aks.outputs.app-url }}"
        echo "ğŸ¥ Health Checks: âœ… Passou"
        echo "ğŸ”‘ Auth Tests: âœ… Passou"
        echo ""
        echo "ğŸš€ AplicaÃ§Ã£o estÃ¡ rodando no AKS!"

  # ============================================================================
  # JOB 5: ROLLBACK (se falhar)
  # ============================================================================
  rollback-on-failure:
    name: ğŸ”„ Auto Rollback
    runs-on: ubuntu-latest
    needs: [deploy-to-aks, health-checks]
    if: failure()
    
    steps:
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl  
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Realizar rollback
    - name: ğŸ”„ Perform Rollback
      run: |
        echo "âŒ Deployment falhou! Verificando se hÃ¡ versÃ£o anterior para rollback..."
        
        # Verificar se deployment existe
        if kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} &> /dev/null; then
          echo "ğŸ“‹ Deployment encontrado, fazendo rollback..."
          
          # Rollback para versÃ£o anterior
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }}
            
          # Aguardar rollback completar
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s
            
          echo "ğŸ”„ Rollback concluÃ­do!"
        else
          echo "âš ï¸ Deployment nÃ£o existe ainda, limpando recursos criados..."
          
          # Limpar recursos criados no deploy que falhou
          kubectl delete all -l app.kubernetes.io/name=student-service -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          echo "ğŸ§¹ Recursos limpos!"
        fi
        
    - name: ğŸ“¢ Rollback Notification
      run: |
        echo "ğŸ”„ ROLLBACK REALIZADO!"
        echo "âŒ O deployment falhou e foi revertido para a versÃ£o anterior"
        echo "ğŸ“‹ Verifique os logs para identificar o problema"