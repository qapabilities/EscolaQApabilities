# ğŸš€ CD Pipeline - Continuous Deployment to AKS
# Escola QApabilities - Student Service
# 
# Triggers: Push para main + Manual
# Jobs: Build & Push Docker â†’ ACR, Deploy â†’ AKS, Health Checks

name: CD - Deploy para AKS

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

env:
  AZURE_RESOURCE_GROUP: 'rg-escola-qapabilities'
  AZURE_CLUSTER_NAME: 'aks-escola-qapabilities'
  AZURE_REGISTRY_NAME: 'crescolaqapabilities'
  IMAGE_NAME: 'student-service'
  NAMESPACE: 'escola-qapabilities'
  DEPLOYMENT_NAME: 'student-service'

jobs:
  # ============================================================================
  # JOB 1: BUILD & PUSH DOCKER IMAGE
  # ============================================================================
  build-and-push:
    name: ğŸ³ Build & Push to ACR
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      
    steps:
    # Checkout do cÃ³digo
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Login no Azure Container Registry
    - name: ğŸ³ Login to ACR
      run: |
        az acr login --name ${{ env.AZURE_REGISTRY_NAME }}
        
    # Configurar metadados da imagem
    - name: ğŸ·ï¸ Extract Metadata
      id: meta
      run: |
        IMAGE_TAG="${{ env.AZURE_REGISTRY_NAME }}.azurecr.io/${{ env.IMAGE_NAME }}"
        
        if [ "${{ github.event_name }}" = "push" ]; then
          VERSION="v$(date +%Y%m%d%H%M%S)-${GITHUB_SHA::8}"
        else
          VERSION="manual-$(date +%Y%m%d%H%M%S)"
        fi
        
        FULL_TAG="${IMAGE_TAG}:${VERSION}"
        LATEST_TAG="${IMAGE_TAG}:latest"
        
        echo "tags=${FULL_TAG}" >> $GITHUB_OUTPUT
        echo "latest=${LATEST_TAG}" >> $GITHUB_OUTPUT
        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        
        echo "ğŸ·ï¸ Image Tag: ${FULL_TAG}"
        echo "ğŸ·ï¸ Latest Tag: ${LATEST_TAG}"
        
    # Setup Docker Buildx para multi-platform builds
    - name: ğŸ”§ Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    # Build e Push da imagem Docker para ARM64
    - name: ğŸ—ï¸ Build & Push Docker Image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/arm64
        push: true
        tags: |
          ${{ steps.meta.outputs.tags }}
          ${{ steps.meta.outputs.latest }}
        build-args: |
          BUILD_VERSION=${{ steps.meta.outputs.version }}

  # ============================================================================
  # JOB 2: DEPLOY TO AKS
  # ============================================================================
  deploy-to-aks:
    name: â˜¸ï¸ Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.get-url.outputs.app-url }}
      
    steps:
    # Checkout do cÃ³digo
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Verificar conectividade com cluster
    - name: ğŸ” Check Cluster Connection
      run: |
        kubectl cluster-info
        kubectl get nodes
        
    # Aplicar configuraÃ§Ãµes base (se necessÃ¡rio)
    - name: ğŸ“‹ Apply Base Configurations
      run: |
        # Aplicar configuraÃ§Ãµes base
        echo "ğŸ“‹ Applying base configurations..."
        kubectl apply -f k8s/namespace.yaml
        kubectl apply -f k8s/configmap.yaml
        kubectl apply -f k8s/secret.yaml
        
        echo "âœ… Base configurations applied!"
        echo "ğŸ“‹ Using SQLite database - no external database required!"
        
    # Atualizar imagem no deployment
    - name: ğŸ”„ Update Deployment Image
      run: |
        # Atualizar a imagem no manifesto
        sed -i "s|escolaqapabilities/student-service:latest|${{ needs.build-and-push.outputs.image-tag }}|g" k8s/student-service.yaml
        
        # Aplicar o deployment atualizado
        kubectl apply -f k8s/student-service.yaml
        kubectl apply -f k8s/ingress.yaml
        
    # Aguardar deployment estar pronto
    - name: â³ Wait for Deployment
      run: |
        echo "â³ Aguardando deployment estar pronto (pode levar alguns minutos)..."
        kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --timeout=900s
          
        echo "âœ… Deployment concluÃ­do com sucesso!"
        
    # Obter URL da aplicaÃ§Ã£o
    - name: ğŸŒ Get Application URL
      id: get-url
      run: |
        # Aguardar IP externo do LoadBalancer do student-service
        echo "ğŸ” Obtendo IP externo do LoadBalancer..."
        
        for i in {1..30}; do
          EXTERNAL_IP=$(kubectl get service ${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }} \
            -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            
          if [ ! -z "$EXTERNAL_IP" ]; then
            echo "ğŸŒ IP Externo encontrado: $EXTERNAL_IP"
            echo "app-url=http://$EXTERNAL_IP" >> $GITHUB_OUTPUT
            break
          fi
          
          echo "â³ Aguardando IP externo... (tentativa $i/30)"
          sleep 10
        done
        
        if [ -z "$EXTERNAL_IP" ]; then
          echo "âš ï¸ IP externo nÃ£o foi atribuÃ­do apÃ³s 5 minutos"
          echo "ğŸ” Verificando status do service..."
          kubectl describe service ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }}
          
          echo "âš ï¸ Usando ClusterIP para testes internos"
          CLUSTER_IP=$(kubectl get service ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.clusterIP}')
          echo "app-url=http://$CLUSTER_IP" >> $GITHUB_OUTPUT
        fi

  # ============================================================================
  # JOB 3: HEALTH CHECKS & API TESTS
  # ============================================================================
  health-checks:
    name: ğŸ¥ Health Checks & API Tests
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks]
    
    steps:
    # Checkout para testes de API
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4
      
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Health Check bÃ¡sico
    - name: ğŸ¥ Basic Health Check
      run: |
        echo "ğŸ¥ Verificando saÃºde dos pods..."
        
        # Verificar se pods estÃ£o rodando
        kubectl get pods -n ${{ env.NAMESPACE }}
        
        # Verificar logs dos pods
        echo "ğŸ“‹ Ãšltimos logs do deployment:"
        kubectl logs deployment/${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          --tail=20
          
    # Test do endpoint de health
    - name: ğŸ” Health Endpoint Test
      run: |
        # Obter IP do serviÃ§o LoadBalancer
        EXTERNAL_IP=$(kubectl get service ${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
        if [ ! -z "$EXTERNAL_IP" ]; then
          echo "ğŸ” Testando health endpoint via LoadBalancer: http://$EXTERNAL_IP/health"
          
          # Teste direto no LoadBalancer
          for i in {1..10}; do
            if curl -f -s "http://$EXTERNAL_IP/health" > /dev/null; then
              echo "âœ… Health check passou!"
              break
            else
              echo "â³ Aguardando aplicaÃ§Ã£o ficar pronta... (tentativa $i/10)"
              sleep 30
            fi
          done
        else
          echo "ğŸ” LoadBalancer nÃ£o disponÃ­vel, testando via port-forward..."
          
          # Port forward como fallback
          kubectl port-forward service/${{ env.DEPLOYMENT_NAME }} 8080:80 -n ${{ env.NAMESPACE }} &
          PORT_FORWARD_PID=$!
          
          # Aguardar port forward estar pronto
          sleep 10
          
          # Testar endpoint via port-forward
          if curl -f -s "http://localhost:8080/health" > /dev/null; then
            echo "âœ… Health check passou via port-forward!"
          else
            echo "âŒ Health check falhou"
            exit 1
          fi
          
          # Limpar port forward
          kill $PORT_FORWARD_PID 2>/dev/null || true
        fi
        
    # Test bÃ¡sico de autenticaÃ§Ã£o
    - name: ğŸ”‘ Authentication Test
      run: |
        echo "ğŸ”‘ Testando endpoint de autenticaÃ§Ã£o..."
        
        # Obter IP do LoadBalancer
        EXTERNAL_IP=$(kubectl get service ${{ env.DEPLOYMENT_NAME }} \
          -n ${{ env.NAMESPACE }} \
          -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          
        if [ ! -z "$EXTERNAL_IP" ]; then
          echo "ğŸ”‘ Testando login via LoadBalancer: http://$EXTERNAL_IP/api/auth/login"
          
          # Testar login com credenciais seguras
          if curl -X POST "http://$EXTERNAL_IP/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"email": "admin@qapabilities.com", "password": "SecureAdmin2024!"}' \
            -f -s > /dev/null; then
            echo "âœ… AutenticaÃ§Ã£o funcionando!"
          else
            echo "âš ï¸ AutenticaÃ§Ã£o via LoadBalancer falhou, tentando port-forward..."
            
            # Fallback para port-forward
            kubectl port-forward service/${{ env.DEPLOYMENT_NAME }} 8080:80 -n ${{ env.NAMESPACE }} &
            PORT_FORWARD_PID=$!
            sleep 10
            
            if curl -X POST "http://localhost:8080/api/auth/login" \
              -H "Content-Type: application/json" \
              -d '{"email": "admin@qapabilities.com", "password": "SecureAdmin2024!"}' \
              -f -s > /dev/null; then
              echo "âœ… AutenticaÃ§Ã£o funcionando via port-forward!"
            else
              echo "âŒ Falha na autenticaÃ§Ã£o"
            fi
            
            kill $PORT_FORWARD_PID 2>/dev/null || true
          fi
        else
          echo "âš ï¸ LoadBalancer nÃ£o disponÃ­vel, usando port-forward..."
          
          kubectl port-forward service/${{ env.DEPLOYMENT_NAME }} 8080:80 -n ${{ env.NAMESPACE }} &
          PORT_FORWARD_PID=$!
          sleep 10
          
          if curl -X POST "http://localhost:8080/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"email": "admin@qapabilities.com", "password": "SecureAdmin2024!"}' \
            -f -s > /dev/null; then
            echo "âœ… AutenticaÃ§Ã£o funcionando!"
          else
            echo "âŒ Falha na autenticaÃ§Ã£o"
          fi
          
          kill $PORT_FORWARD_PID 2>/dev/null || true
        fi

  # ============================================================================
  # JOB 4: DEPLOYMENT SUCCESS
  # ============================================================================
  deployment-success:
    name: âœ… Deployment Success
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-to-aks, health-checks]
    if: success()
    
    steps:
    - name: ğŸ‰ Deployment Success Notification
      run: |
        echo "ğŸ‰ DEPLOYMENT REALIZADO COM SUCESSO!"
        echo ""
        echo "ğŸ“¦ Imagem: ${{ needs.build-and-push.outputs.image-tag }}"
        echo "ğŸŒ URL: ${{ needs.deploy-to-aks.outputs.app-url }}"
        echo "ğŸ¥ Health Checks: âœ… Passou"
        echo "ğŸ”‘ Auth Tests: âœ… Passou"
        echo ""
        echo "ğŸš€ AplicaÃ§Ã£o estÃ¡ rodando no AKS!"

  # ============================================================================
  # JOB 5: ROLLBACK (se falhar)
  # ============================================================================
  rollback-on-failure:
    name: ğŸ”„ Auto Rollback
    runs-on: ubuntu-latest
    needs: [deploy-to-aks, health-checks]
    if: failure()
    
    steps:
    # Login no Azure
    - name: ğŸ”‘ Azure Login
      uses: azure/login@v2
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
        
    # Configurar kubectl  
    - name: âš™ï¸ Setup kubectl
      run: |
        az aks get-credentials \
          --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
          --name ${{ env.AZURE_CLUSTER_NAME }} \
          --overwrite-existing
          
    # Realizar rollback
    - name: ğŸ”„ Perform Rollback
      run: |
        echo "âŒ Deployment falhou! Verificando se hÃ¡ versÃ£o anterior para rollback..."
        
        # Verificar se deployment existe
        if kubectl get deployment ${{ env.DEPLOYMENT_NAME }} -n ${{ env.NAMESPACE }} &> /dev/null; then
          echo "ğŸ“‹ Deployment encontrado, fazendo rollback..."
          
          # Rollback para versÃ£o anterior
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }}
            
          # Aguardar rollback completar
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.NAMESPACE }} \
            --timeout=600s
            
          echo "ğŸ”„ Rollback concluÃ­do!"
        else
          echo "âš ï¸ Deployment nÃ£o existe ainda, limpando recursos criados..."
          
          # Limpar recursos criados no deploy que falhou
          kubectl delete all -l app.kubernetes.io/name=student-service -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          echo "ğŸ§¹ Recursos limpos!"
        fi
        
    - name: ğŸ“¢ Rollback Notification
      run: |
        echo "ğŸ”„ ROLLBACK REALIZADO!"
        echo "âŒ O deployment falhou e foi revertido para a versÃ£o anterior"
        echo "ğŸ“‹ Verifique os logs para identificar o problema"